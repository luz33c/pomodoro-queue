# 番茄时钟核心逻辑文档

## 概述

本文档详细说明番茄时钟浏览器扩展的核心逻辑架构，包括前端UI与后台脚本的交互机制、状态管理、时间控制等关键功能。

## 架构概览

```
┌─────────────────┐    消息传递    ┌─────────────────┐
│   前端UI组件    │ ──────────→  │   后台脚本      │
│ usePomodoro Hook│ ←──────────  │ background/index │
└─────────────────┘              └─────────────────┘
         │                                │
         │                                │
         ▼                                ▼
┌─────────────────┐              ┌─────────────────┐
│   本地存储      │              │   Chrome API    │
│ (Plasmo Storage)│              │ (alarms, tabs)  │
└─────────────────┘              └─────────────────┘
```

## 核心组件

### 1. usePomodoro Hook

位置：`apps/browser-extension/src/hooks/pomodoro/usePomodoro.ts`

这是前端UI与后台脚本交互的主要接口，提供：

#### 主要功能
- **状态订阅**：从本地存储实时获取番茄时钟状态
- **时间计算**：计算剩余时间和进度百分比
- **UI刷新控制**：根据运行状态选择高频/低频刷新
- **操作接口**：提供开始、暂停、恢复、停止、跳过等操作方法

#### 核心状态

```typescript
export type PomodoroState = {
  phase: PomodoroPhase;         // 当前阶段：idle | focus | short | long
  running: boolean;             // 是否正在运行
  cycleCount: number;           // 已完成的专注周期数
  startedAt?: number;           // 当前阶段开始时间（毫秒）
  endsAt?: number;              // 当前阶段结束时间（毫秒）
  paused: boolean;              // 是否暂停
  pausedAt?: number;            // 暂停时间（毫秒）
  pauseAccumMs: number;         // 累积暂停时长（毫秒）
  config: PomodoroConfig;       // 配置信息
};
```

#### 时间刷新机制

```typescript
// 运行且未暂停时使用RAF进行高频刷新（约60fps），保证倒计时的流畅性
// 其他情况使用1秒间隔刷新，节省性能
if (state?.running && !state.paused) startRaf()
else startInterval()
```

#### 剩余时间计算

```typescript
const remainMs = useMemo(() => {
  // 如果没有运行或没有结束时间，返回0
  if (!state?.running || !state?.endsAt) return 0
  
  // 如果已暂停，计算暂停时的剩余时间（不随时间变化）
  if (state.paused) return Math.max(0, (state.endsAt ?? now) - (state.pausedAt ?? now))
  
  // 正常运行时，计算当前的剩余时间
  return Math.max(0, state.endsAt - now)
}, [state?.running, state?.endsAt, state?.paused, state?.pausedAt, now])
```

### 2. 后台消息处理器

位置：`apps/browser-extension/src/background/messages/`

通过Plasmo的消息传递机制处理前端操作请求：

#### pomodoro.start.ts - 开始番茄时钟
- 接收阶段参数（默认为focus）
- 调用`startPhase()`函数
- 创建或更新番茄队列

#### pomodoro.pause.ts - 暂停计时器
- 记录暂停时间
- 清除Chrome alarms定时器
- 保持当前进度

#### pomodoro.resume.ts - 恢复计时器
- 计算暂停时长
- 调整结束时间
- 重新设置定时器

#### pomodoro.stop.ts - 停止计时器
- 记录当前阶段到历史
- 重置状态到idle
- 清除当前队列
- 关闭严格模式

#### pomodoro.skip.ts - 跳过当前阶段
- 记录被跳过的阶段到历史
- 自动进入下一阶段
- 处理0分钟休息的跳过
- 关闭Break页面（如果从休息状态跳过）

#### pomodoro.config.update.ts - 更新配置
- 应用新的时间配置
- 处理严格模式切换
- 调整当前运行的计时器

#### break.close.ts - 关闭休息页面
- 处理严格模式Break页面的关闭

### 3. 后台核心逻辑

位置：`apps/browser-extension/src/background/index.ts`

#### 主要功能

##### Chrome事件监听
```typescript
// 扩展安装时初始化状态
chrome.runtime.onInstalled.addListener(() => {
  ensureInitialState();
});

// 扩展启动时检查严格模式状态
chrome.runtime.onStartup.addListener(async () => {
  const s = await storage.get<PomodoroState>(STORAGE_KEY);
  const inBreak = s?.phase === "short" || s?.phase === "long"
  if (inBreak && s?.config?.strictMode) {
    await beginStrictBreak();
  }
  // ...
});

// 定时器到期处理
chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name !== PHASE_ALARM) return;
  // 记录完成的阶段到历史
  // 计算下一阶段
  // 处理严格模式切换
  // 发送通知
});
```

##### 阶段转换逻辑
```typescript
export function getNextStateAfterPhase(s: PomodoroState): PomodoroState {
  const cfg = s.config;
  if (s.phase === 'focus') {
    const newCycle = s.cycleCount + 1;
    // 每完成longEvery个专注周期后进入长休息，否则短休息
    const nextPhase: PomodoroPhase =
      newCycle % cfg.longEvery === 0 ? 'long' : 'short';
    // ...
  }
  if (s.phase === 'short' || s.phase === 'long') {
    // 休息结束后进入专注阶段
    return { ...s, phase: 'focus', /* ... */ };
  }
  return s;
}
```

##### 严格模式处理
```typescript
// 进入休息阶段时的严格模式处理
if (next.config?.strictMode && (next.phase === 'short' || next.phase === 'long')) {
  await beginStrictBreak(); // 打开Break页面
} else if (!next.config?.strictMode && (next.phase === 'short' || next.phase === 'long')) {
  await showOverlayOnAllOpenTabs(); // 显示遮罩
  await endStrictBreak(); // 确保关闭Break页面
} else {
  await endStrictBreak(); // 关闭Break页面
}
```

## 数据流程

### 1. 开始番茄时钟流程

```
用户点击开始
    ↓
usePomodoro.start()
    ↓
sendToBackground("pomodoro.start")
    ↓
pomodoro.start.ts handler
    ↓
startPhase() in background/index.ts
    ↓
更新状态 → 设置定时器 → 发送通知 → 处理严格模式
```

### 2. 阶段自然结束流程

```
Chrome alarms定时器触发
    ↓
chrome.alarms.onAlarm listener
    ↓
记录完成的阶段到历史
    ↓
getNextStateAfterPhase() 计算下一阶段
    ↓
更新状态 → 设置新定时器 → 发送通知 → 处理严格模式切换
```

### 3. 暂停/恢复流程

```
用户点击暂停
    ↓
usePomodoro.pause()
    ↓
pauseTimer() → 记录pausedAt时间 → 清除定时器

用户点击恢复
    ↓
usePomodoro.resume()
    ↓
resumeTimer() → 计算暂停时长 → 调整endsAt时间 → 重设定时器
```

## 存储机制

### 存储键值

- `STORAGE_KEY = "pomodoroState"` - 当前番茄时钟状态
- `HISTORY_KEY = "pomodoroHistory"` - 历史记录数组
- `CURRENT_QUEUE_KEY = "pomodoroCurrentQueue"` - 当前队列信息

### 历史记录结构

```typescript
export type PomodoroHistoryEntry = {
  id: string;
  phase: Exclude<PomodoroPhase, "idle">;
  title: string;                    // 本地化标题
  startedAt: number;                // 开始时间
  endedAt: number;                  // 结束时间
  durationMs: number;               // 实际时长
  queueId?: string;                 // 所属队列ID
};
```

### 队列机制

```typescript
export type CurrentQueue = {
  id: string;        // 队列唯一ID
  startedAt: number; // 队列开始时间
};
```

队列用于将相关的番茄时钟会话分组，便于统计和分析。

## 时间计算细节

### 分钟转毫秒
```typescript
function minutesToMs(m: number) {
  return Math.round(m * 60 * 1000);
}
```

### 结束时间计算
```typescript
function calcEndsAt(now: number, phase: PomodoroPhase, cfg: PomodoroConfig) {
  let dur = 0;
  if (phase === 'focus') dur = minutesToMs(cfg.focusMin);
  else if (phase === 'short') dur = minutesToMs(cfg.shortMin);
  else if (phase === 'long') dur = minutesToMs(cfg.longMin);
  return dur ? now + dur : undefined; // 0分钟时返回undefined
}
```

### 暂停时间处理
```typescript
// 恢复时调整结束时间
const pausedDelta = now - s.pausedAt;
const next: PomodoroState = {
  ...s,
  paused: false,
  pausedAt: undefined,
  pauseAccumMs: (s.pauseAccumMs ?? 0) + pausedDelta, // 累积暂停时长
  endsAt: s.endsAt + pausedDelta,                    // 延后结束时间
};
```

## 配置系统

### 默认配置
```typescript
export const DEFAULT_CONFIG: PomodoroConfig = {
  focusMin: 25,      // 专注时间25分钟
  shortMin: 5,       // 短休息5分钟
  longMin: 20,       // 长休息20分钟
  longEvery: 4,      // 每4个专注周期后长休息
  strictMode: true,  // 默认开启严格模式
};
```

### 配置应用逻辑
```typescript
export async function applyConfig(cfg: PomodoroState['config']) {
  const s = await storage.get<PomodoroState>(STORAGE_KEY);
  const next: PomodoroState = { ...s, config: cfg };
  
  // 如果正在运行，保持剩余时间不变
  if (next.running && next.startedAt && next.phase !== 'idle') {
    const now = Date.now();
    const remaining = Math.max(0, (s.endsAt ?? now) - now);
    next.endsAt = now + remaining;
  }
  
  await storage.set(STORAGE_KEY, next);
  
  // 处理严格模式切换
  if (s && s.running && (s.phase === 'short' || s.phase === 'long')) {
    if (cfg.strictMode && !s.config?.strictMode) {
      await beginStrictBreak(); // 切换到严格模式
    } else if (!cfg.strictMode && s.config?.strictMode) {
      await showOverlayOnAllOpenTabs(); // 切换到普通模式
      await endStrictBreak();
    }
  }
}
```

## 错误处理与边界情况

### 0分钟休息处理
```typescript
// 在跳过和自然结束时都会检查
if ((next.phase === "short" || next.phase === "long") && !next.endsAt) {
  next = getNextStateAfterPhase(next); // 直接跳到下一阶段
}
```

### 扩展重启恢复
```typescript
// 扩展启动时检查状态
chrome.runtime.onStartup.addListener(async () => {
  const s = await storage.get<PomodoroState>(STORAGE_KEY);
  const inBreak = s?.phase === "short" || s?.phase === "long"
  // 根据状态和配置恢复严格模式
  if (inBreak && s?.config?.strictMode) {
    await beginStrictBreak();
  } else if (inBreak && !s?.config?.strictMode) {
    await showOverlayOnAllOpenTabs();
  } else {
    await endStrictBreak();
  }
});
```

### 时间同步
- 前端使用`requestAnimationFrame`或`setInterval`更新当前时间
- 后台使用Chrome alarms API确保准确的定时触发
- 暂停时保存精确的时间戳，恢复时重新计算

## 总结

番茄时钟的核心逻辑基于以下关键设计原则：

1. **状态驱动**：所有UI都基于存储中的状态进行渲染
2. **消息传递**：前端通过消息与后台通信，保证数据一致性
3. **时间精确**：使用Chrome alarms API确保定时器准确性
4. **状态持久化**：所有状态保存到本地存储，支持扩展重启恢复
5. **严格模式**：根据配置自动处理Break页面和内容遮罩
6. **历史追踪**：完整记录每个阶段的执行情况

这种架构确保了番茄时钟功能的可靠性、准确性和用户体验的一致性。