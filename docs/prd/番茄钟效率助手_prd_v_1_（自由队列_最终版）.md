# 番茄钟效率助手 · 产品需求文档 V1（自由队列·最终版）

> 本文是 **第一版（V1）** 的权威 PRD，用于指导设计与前端直接落地。本版本只包含 **自由番茄队列**（不依赖任务/todolist），并以移动优先的单端实现为目标；未来可扩展至 App 与浏览器插件。

---

## 0. 文档目的
- 让团队在**无需口头补充**的前提下完成 UI 设计、前端开发与验收。
- 作为未来版本（V2：任务驱动等）的基础接口与交互规范基线。

---

## 1. 产品概述
- **一句话**：一键「开始」即进入稳定的 **专注→休息→专注** 节奏，**无限执行**，直到手动终止。
- **核心价值**：
  1) 低摩擦：任何时候点「开始」即可；
  2) 稳节奏：内建短/长休策略，形成可持续节奏；
  3) 清反馈：进度环 + 剩余时间 + 历史记录，状态一目了然。
- **平台**：移动优先（响应式），可平滑迁移到浏览器插件 Popup 和原生 App。

---

## 2. 范围与非范围
- **范围（V1）**：
  - 自由番茄队列（无限执行）；
  - 规则设置向导；
  - 计时环与主操作（开始/暂停/继续/终止）；
  - 已执行历史；
  - 基础本地持久（可选）。
- **非范围（留待 V2+）**：任务驱动队列、todolist、账号/云同步、复杂统计与日历同步、音视频提醒（可做轻量增强）。

---

## 3. 术语与命名
- **专注段（work）**：一次专注计时，默认 25 分钟。
- **短休息（short break）**：默认 5 分钟。
- **长休息（long break）**：默认 20 分钟。
- **长休间隔（longEvery）**：累计完成 N 个专注段后插入 1 次长休（默认 4，N≥2）。
- **番茄队列（Queue）**：由 work 与 break 组成的执行**流**。本版为**流式/无限队列**（运行期动态产出下一段，而非一次性预铺时间线）。

---

## 4. 关键用户故事（User Stories）
1. 作为用户，我希望点一次「开始」就进入专注，不必先添加任务。
2. 作为用户，我希望专注结束后自动进入休息，休息后自动回到专注，直到我主动终止。
3. 作为用户，我希望能随时暂停/继续，并在历史里看到每段完成时间与类型。

---

## 5. 信息架构（IA）与页面结构

### 5.1 首页（计时仪表盘）
- **上部**：计时环（圆环进度）+ 中央 `MM:SS` 剩余时间 + 阶段文案（专注中/短休息/长休息/未开始/已终止）。
- **中部操作区**：
  - 空闲态：**主按钮「开始」**；
  - 运行态：**暂停** + **终止队列**；
  - 暂停态：**继续** + **终止队列**；
- **下部**：已执行历史（倒序，最新在上）。仅展示**历史**与**当前**，不显示未来段。
- **右上角齿轮按钮（可选）**：打开规则设置向导（与开始流程相同）。

### 5.2 空态
- 首次进入/无队列：展示引导文案——“本版仅支持『自由番茄队列』，设置规则后将**无限执行**，直到你终止。”

---

## 6. 交互流程（Flow）

### 6.1 首次开始（推荐路径）
1) 用户点击「开始」。
2) 弹出**规则向导**：填写或使用默认值（25/5/20，长休间隔 4）。
3) 点击「生成并开始」后，立即进入**第一段专注**；随后系统按规则自动衔接休息/下一段专注，**无限循环**。

### 6.2 运行中
- 倒计时归零 ⇒ 该段状态置为完成，写入历史 ⇒ 自动进入下一段。
- 运行中可点击「暂停」；暂停后显示「继续」与「终止队列」。

### 6.3 终止
- 点击「终止队列」：结束当前段（记入历史），停止产出新段，整体状态置为**已终止**；主按钮回到「开始」。

---

## 7. 规则（业务逻辑）
- **长休策略**：跨段累计 `workCount`，若 `workCount % longEvery === 0` 且 `longBreak>0`，则在该 work 之后插入**长休息**；否则插入短休（若 `shortBreak>0`）。
- **尾部处理**：自由队列为**无限流**，不存在末尾多余休息的问题；终止时以“结束当前段”的方式收尾。
- **自动衔接**：每段完成后自动开始下一段，无需额外点击。

---

## 8. 规则向导（单步）
- **字段与默认**：
  - 专注时长：`workDuration`（分钟，默认 25，最小 1）
  - 短休时长：`shortBreak`（分钟，默认 5，可 0）
  - 长休时长：`longBreak`（分钟，默认 20，可 0）
  - 长休间隔：`longEvery`（默认 4，**最小 2**）
- **校验**：
  - `workDuration ≥ 1`；`shortBreak ≥ 0`；`longBreak ≥ 0`；`longEvery ≥ 2`；
  - 当休息为 0 时，交互提示“无休息流”。
- **确认**：点击「生成并开始」后即进入第一段专注。

---

## 9. 数据模型（前端约定）
> 供实现参考，实际可按技术栈微调。

```ts
export type SegmentType = 'work' | 'shortBreak' | 'longBreak';

export interface QueueRules {
  workDuration: number;    // 秒（默认 1500）
  shortBreak: number;      // 秒（默认 300，可 0）
  longBreak: number;       // 秒（默认 1200，可 0）
  longEvery: number;       // >=2（默认 4）
}

export interface Segment {
  id: string;
  type: SegmentType;
  title: string;           // '专注时段' | '短休息' | '长休息'
  duration: number;        // 秒
  startedAt?: number;      // epoch ms
  endedAt?: number;        // epoch ms
  remaining?: number;      // 暂停时的剩余秒
  status: 'pending' | 'running' | 'done';
}

export interface QueueState {
  rules: QueueRules | null;
  current: Segment | null;
  status: 'idle' | 'running' | 'paused' | 'terminated';
  history: Segment[];      // 已完成段
  workCount: number;       // 已完成 work 段累计
  deadline: number | null; // 当前段结束时间戳
}
```

---

## 10. 算法与状态机

### 10.1 生成下一段（自由队列）
```ts
function nextSegment(prevType: SegmentType | null, rules: QueueRules, workCount: number): Segment {
  if (prevType === 'work') {
    const isLong = rules.longEvery >= 2 && workCount % rules.longEvery === 0 && rules.longBreak > 0;
    return { id: uuid(), type: isLong ? 'longBreak' : 'shortBreak', title: isLong ? '长休息' : '短休息', duration: isLong ? rules.longBreak : rules.shortBreak, status: 'pending' };
  }
  return { id: uuid(), type: 'work', title: '专注时段', duration: rules.workDuration, status: 'pending' };
}
```

### 10.2 计时状态机
```
idle → running → paused → running → terminated
```
- **计时原则**：以 `deadline = startedAt + remaining` 回算剩余；UI 每 250–500ms 刷新，避免 setInterval 漂移。
- **段完成**：`current` 写入历史；若 `type==='work'`，`workCount++`；随后 `start(nextSegment(...))`（自动衔接）。
- **终止**：将当前段标记完成并写入历史，状态置 `terminated`，重置倒计时与环。

---

## 11. React 组件拆分与职责
- **`AppShell`**：路由与全局状态；注入 `TimerService`；可选持久化（localStorage）。
- **`TimerCard`**：计时环、剩余时间、阶段文案、主按钮（开始/暂停/继续/终止）。
- **`HistoryList`**：渲染历史记录（倒序，显示类型/分钟数/完成时刻）。
- **`WizardModal`**：规则设置；输出 `QueueRules` 并触发开始。
- **Hooks/Service**：
  - `useTimerEngine()`：启动/暂停/继续/终止、deadline 回算、震动/通知（可选）。
  - `useQueueStream()`：管理 `workCount` 与 `nextSegment` 产出。

---

## 12. 视觉与交互规范（移动优先）
- **计时环**：
  - 半径/粗细：r≈92、stroke≈16（可按屏宽自适应）；
  - 进度从 0→100%，专注为主红，休息为灰或浅色；
  - 中央数字 `32–40px`，等宽字体；
- **主按钮**：
  - 文案固定为 **「开始」**（空闲态），运行/暂停态分别为「暂停 / 继续」，破坏性为「终止队列」；
  - 圆角≥999px，触达≥44×44pt，按下有 120ms 回弹；
- **历史列表**：行卡片样式，左类型/标题，右完成时间；最新在上；
- **对比度**：文本与按钮满足 WCAG AA；支持暗色模式（优先跟随系统）。

---

## 13. 校验与错误处理
- 规则输入：
  - 非法值（空/负数/`longEvery<2`）阻止提交并明确提示；
  - 所有休息为 0 时弹确认对话框（“将以无休息方式连续专注，确认继续？”）。
- 运行异常：
  - 计时器被系统杀死/页面切换：以 `deadline` 回算；若已过期则视为完成并推进到下一段。

---

## 14. 可访问性（a11y）
- 所有按钮具备 `aria-label`；
- 阶段切换时提供轻震/提示音（可选开关）；
- 进度环有等价文本（屏幕阅读器读取“专注中，剩余 12 分 10 秒”）。

---

## 15. 埋点与指标（建议）
- `queue_start`（含规则）；`queue_pause`/`queue_resume`/`queue_terminate`；
- `segment_complete`（类型/时长）；
- `focus_minutes_total`、`work_segments_count`（日/周聚合）。

---

## 16. 验收标准（关键用例）
1. **一键开始**：点击「开始」→ 向导 → 立即进入第一段专注；倒计时与圆环同步变化。
2. **无限循环**：按默认规则连续运行 ≥9 段；在第 4、8 … 个专注后出现长休；过程不中断。
3. **暂停/继续**：暂停后剩余时间冻结；继续后从冻结处恢复；
4. **终止**：点击「终止队列」，当前段被记入历史，状态变为“已终止”，不再产出新段；
5. **历史**：每个已完成段显示类型、分钟数与完成时间（最新在上）；
6. **文案一致**：空闲态主按钮为“开始”；运行/暂停态按钮文案与规范一致。

---

## 17. 交付清单与排期（建议）
- **交付物**：
  1) 视觉稿（首页 + 规则向导 + 历史样式 + 暗色态）；
  2) 可交互前端（含无限队列与状态机、持久化可选）；
  3) 测试用例（覆盖 §16）。
- **排期**：
  - 第 1 周：UI 实现（TimerCard/History/Wizard）+ 引擎与状态机；
  - 第 2 周：细化动效/暗色/边界处理与 QA；
  - 第 3 周（缓冲）：性能与可访问性优化、埋点接入。

---

## 18. 未来路线（不在本版实现）
- **V2**：todolist + 任务驱动静态队列（从任务页顶部按钮创建）+ 底部导航；
- 声音提示/系统通知、统计与复盘、跨端同步（账号）。

